<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earth Shipping Routes (Pixel-based)</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: #050814;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    .leaflet-container {
      background: #000;
    }
  </style>
</head>
<body>

<div id="map"></div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  crossorigin=""
></script>

<script>
/* =========================
   MAP CONFIGURATION
   ========================= */
const IMG_URL = 'https://i.postimg.cc/YSDwq0ms/map.webp';
const IMG_WIDTH = 1005;
const IMG_HEIGHT = 500;

const map = L.map('map', {
  crs: L.CRS.Simple,
  minZoom: -2,
  maxZoom: 2
});

const bounds = [[0,0], [IMG_HEIGHT, IMG_WIDTH]];
L.imageOverlay(IMG_URL, bounds).addTo(map);
map.fitBounds(bounds);

/* =========================
   PORT ICON
   ========================= */
function createPortIcon(selected = false) {
  return L.icon({
    iconUrl: 'https://i.postimg.cc/wMs4zThh/anchor.png',
    iconSize: selected ? [48, 48] : [42, 42],
    iconAnchor: [24, 24]
  });
}

/* =========================
   PORT DATA (PIXEL COORDINATES)
   ========================= */
const ports = [
  { name: 'London', coords: [102, 503] },       // [y, x]
  { name: 'Konigsberg', coords: [97, 560] },
  { name: 'Miami', coords: [171, 273] }
];

/* =========================
   SEA NODE GRAPH (PIXEL BASED)
   ========================= */
const seaNodes = [
  { id: 'NA1', coords: [50, 100], neighbors: ['NA2', 'NA3'] },
  { id: 'NA2', coords: [70, 200], neighbors: ['NA1', 'NA4'] },
  { id: 'NA3', coords: [100, 300], neighbors: ['NA1'] },
  { id: 'NA4', coords: [150, 250], neighbors: ['NA2'] },
  // Add additional nodes as needed for route calculations
];

const seaNodeById = {};
seaNodes.forEach(n => { seaNodeById[n.id] = n; });

function distance(a, b) {
  const dx = a[1] - b[1];
  const dy = a[0] - b[0];
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearestSeaNode(coord) {
  let best = null, bestDist = Infinity;
  seaNodes.forEach(node => {
    const d = distance(coord, node.coords);
    if(d < bestDist){ bestDist = d; best = node; }
  });
  return best;
}

function findSeaRoute(startNode, endNode) {
  const openSet = new Set([startNode.id]);
  const cameFrom = {};
  const gScore = {};
  const fScore = {};

  seaNodes.forEach(n => { gScore[n.id] = Infinity; fScore[n.id] = Infinity; });

  gScore[startNode.id] = 0;
  fScore[startNode.id] = distance(startNode.coords, endNode.coords);

  function lowestF() {
    let best = null, bestVal = Infinity;
    openSet.forEach(id => { if(fScore[id]<bestVal){bestVal=fScore[id]; best=id;} });
    return best;
  }

  while(openSet.size){
    const currentId = lowestF();
    if(currentId === endNode.id){
      const path = [];
      let cur = currentId;
      while(cur){
        path.unshift(seaNodeById[cur]);
        cur = cameFrom[cur];
      }
      return path;
    }

    openSet.delete(currentId);
    const current = seaNodeById[currentId];

    current.neighbors.forEach(nid => {
      const neighbor = seaNodeById[nid];
      const tentative = gScore[currentId]+distance(current.coords, neighbor.coords);
      if(tentative<gScore[nid]){
        cameFrom[nid]=currentId;
        gScore[nid]=tentative;
        fScore[nid]=tentative+distance(neighbor.coords,endNode.coords);
        openSet.add(nid);
      }
    });
  }
  return null;
}

/* =========================
   PORT INTERACTION
   ========================= */
const portMarkers = {};
let selectedPorts = [];
let routeLine = null;

ports.forEach(port => {
  const marker = L.marker(port.coords, {
    icon: createPortIcon(false),
    title: port.name
  }).addTo(map);

  portMarkers[port.name] = marker;
  marker.on('click', () => handlePortClick(port));
});

function updatePortIcons(){
  ports.forEach(port=>{
    const selected = selectedPorts.some(p=>p.name===port.name);
    portMarkers[port.name].setIcon(createPortIcon(selected));
  });
}

function handlePortClick(port){
  if(selectedPorts.some(p=>p.name===port.name)) return;
  selectedPorts.push(port);
  if(selectedPorts.length>2) selectedPorts.shift();
  updatePortIcons();
  updateRoute();
}

function updateRoute(){
  if(routeLine){
    map.removeLayer(routeLine);
    routeLine=null;
  }
  if(selectedPorts.length<2) return;

  const start = selectedPorts[0];
  const end = selectedPorts[1];

  const seaPath = findSeaRoute(findNearestSeaNode(start.coords), findNearestSeaNode(end.coords));
  const coords = [start.coords, ...(seaPath ? seaPath.map(n=>n.coords) : []), end.coords];

  routeLine = L.polyline(coords, {
    color: '#00bcd4',
    weight: 4,
    opacity: 0.9
  }).addTo(map);

  map.fitBounds(routeLine.getBounds(), {padding: [40,40]});
}
</script>

</body>
</html>
