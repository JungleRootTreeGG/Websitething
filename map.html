<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMC Shipping Routes - Map</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
<style>
html, body { margin:0; padding:0; height:100%; width:100%; }
#map { width: 100%; height: 100%; }
.leaflet-container { background:#000; }

/* Port label styling */
.port-label {
  color: #fff;
  font-weight: bold;
  font-size: 12px;
  text-shadow: 1px 1px 2px #000;
  pointer-events: none;
}
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script>
// =========================
// CONFIGURATION
// =========================
const IMG_URL = 'https://i.postimg.cc/YSDwq0ms/map.webp';
const IMG_WIDTH = 1005;
const IMG_HEIGHT = 500;

const map = L.map('map', {crs:L.CRS.Simple, minZoom:0, maxZoom:3});
const bounds = [[0,0],[IMG_HEIGHT,IMG_WIDTH]];
L.imageOverlay(IMG_URL, bounds).addTo(map);
map.fitBounds(bounds);

function invertY(y){ return IMG_HEIGHT - y; }

function createPortIcon(selected=false){
  return L.icon({
    iconUrl:'https://i.postimg.cc/wMs4zThh/anchor.png',
    iconSize: selected?[36,36]:[32,32],
    iconAnchor:[16,16]
  });
}

// =========================
// PORT DATA (with Minecraft coords for calibration)
// =========================
const MC_A = { x:-10936, z:-3646, px:277, py:174 }; // Miami
const MC_B = { x:13,     z:-7030, px:503, py:102 }; // London

const scaleX = (MC_B.px - MC_A.px) / (MC_B.x - MC_A.x);
const scaleY = (MC_B.py - MC_A.py) / (MC_B.z - MC_A.z);

function mcToPixel(x,z){
  const px = MC_A.px + (x - MC_A.x) * scaleX;
  const py = MC_A.py + (z - MC_A.z) * scaleY;
  return [invertY(py), px];
}

// Define ports using Minecraft coords, will auto-convert to pixels
const ports = [
  { name:'Miami', coords: mcToPixel(-10936,-3646) },
  { name:'London', coords: mcToPixel(13,-7030) },
  { name:'Konigsberg', coords: mcToPixel(2787,-7485) }
];

// =========================
// PREDEFINED ROUTES (pixels) - you can regenerate with auto-routing later
// =========================
const routes = [
  { from:'Miami', to:'London', coords:[ports[0].coords, ports[1].coords] },
  { from:'Miami', to:'Konigsberg', coords:[ports[0].coords, ports[1].coords, [invertY(93),520],[invertY(84),528],[invertY(93),538],ports[2].coords] },
  { from:'London', to:'Konigsberg', coords:[ports[1].coords, [invertY(93),520],[invertY(84),528],[invertY(93),538],ports[2].coords] }
];

// =========================
// PORT INTERACTIONS
// =========================
const portMarkers = {};
let selectedPorts = [];
let routeLine = null;

ports.forEach(port => {
  // Anchor marker
  const marker = L.marker(port.coords,{icon:createPortIcon(false), title:port.name}).addTo(map);
  portMarkers[port.name] = marker;

  // Label marker (separate icon)
  L.marker(port.coords,{
    icon:L.divIcon({
      className:'port-label',
      html:port.name,
      iconAnchor:[-10,-16]
    })
  }).addTo(map);

  marker.on('click', ()=>handlePortClick(port));
});

function updatePortIcons(){
  ports.forEach(port=>{
    const selected = selectedPorts.some(p=>p.name===port.name);
    portMarkers[port.name].setIcon(createPortIcon(selected));
  });
}

function handlePortClick(port){
  if(selectedPorts.some(p=>p.name===port.name)) return;
  selectedPorts.push(port);
  if(selectedPorts.length>2) selectedPorts.shift();
  updatePortIcons();
  updateRoute();
}

// Deselect by clicking on empty map
map.on('click', e=>{
  const clickedOnPort = ports.some(p=>{
    const dx = e.latlng.lat - p.coords[0];
    const dy = e.latlng.lng - p.coords[1];
    return Math.sqrt(dx*dx + dy*dy)<5;
  });
  if(!clickedOnPort){
    selectedPorts=[];
    updatePortIcons();
    if(routeLine){ map.removeLayer(routeLine); routeLine=null; }
    window.parent.postMessage({ startPort:null, endPort:null, portsAlongRoute:[] }, '*');
  }
});

// =========================
// UPDATE ROUTE
// =========================
function updateRoute(){
  if(routeLine){ map.removeLayer(routeLine); routeLine=null; }
  if(selectedPorts.length<2) return;

  const start = selectedPorts[0].name;
  const end = selectedPorts[1].name;

  const route = routes.find(r=>(r.from===start && r.to===end)||(r.from===end && r.to===start));
  if(!route) return;

  routeLine = L.polyline(route.coords,{color:'#00bcd4',weight:4,opacity:0.9}).addTo(map);
  map.fitBounds(routeLine.getBounds(),{padding:[40,40]});

  let portsAlongRoute = [start];
  ports.forEach(p=>{
    if(p.name!==start && p.name!==end){
      const match = route.coords.some(c=>c[0]===p.coords[0] && c[1]===p.coords[1]);
      if(match) portsAlongRoute.push(p.name);
    }
  });
  portsAlongRoute.push(end);

  window.parent.postMessage({ startPort:start, endPort:end, portsAlongRoute }, '*');
}
</script>
</body>
</html>
