<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SMC Shipping Routes – Auto Sea Routing</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
html, body { margin:0; padding:0; }
#map {
  width: 1005px;
  height: 500px;
}
.leaflet-container { background:#000; }

.port-label {
  color:#fff;
  font-weight:bold;
  font-size:11px;
  text-shadow:1px 1px 2px #000;
  pointer-events:none;
}
</style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* =========================
   MAP CONFIG
========================= */
const IMG_URL = 'https://i.postimg.cc/3xRtYPkG/map-Nero-AI-Image-Upscaler-Photo-Face.webp';
const IMG_W = 1005;
const IMG_H = 500;

const map = L.map('map', {
  crs: L.CRS.Simple,
  minZoom: 0,
  maxZoom: 3,
  zoomControl: false
});

const bounds = [[0,0],[IMG_H,IMG_W]];
L.imageOverlay(IMG_URL, bounds).addTo(map);
map.fitBounds(bounds);

/* =========================
   COORD TRANSFORM
   Minecraft Earth → Pixel
========================= */
const MC_BOUNDS = {
  minX: -10936,
  maxX: 2787,
  minZ: -7485,
  maxZ: -3646
};

function mcToPixel(x,z){
  const px = (x - MC_BOUNDS.minX) / (MC_BOUNDS.maxX - MC_BOUNDS.minX) * IMG_W;
  const py = (z - MC_BOUNDS.minZ) / (MC_BOUNDS.maxZ - MC_BOUNDS.minZ) * IMG_H;
  return [IMG_H - py, px];
}

/* =========================
   PORT DATA (REAL)
========================= */
const ports = [
  { name:'Miami',       mc:{x:-10936,z:-3646} },
  { name:'London',      mc:{x:13,z:-7030} },
  { name:'Konigsberg',  mc:{x:2787,z:-7485} }
];

ports.forEach(p=>{
  p.coords = mcToPixel(p.mc.x,p.mc.z);
});

/* =========================
   ICONS
========================= */
function portIcon(sel){
  return L.icon({
    iconUrl:'https://i.postimg.cc/wMs4zThh/anchor.png',
    iconSize: sel?[34,34]:[30,30],
    iconAnchor:[15,15]
  });
}

/* =========================
   SEA GRID
========================= */
const GRID = 5; // px per cell
const cols = Math.floor(IMG_W / GRID);
const rows = Math.floor(IMG_H / GRID);
const sea = [];

const img = new Image();
img.crossOrigin = 'anonymous';
img.src = IMG_URL;

img.onload = () => {
  const c = document.createElement('canvas');
  c.width = IMG_W;
  c.height = IMG_H;
  const ctx = c.getContext('2d');
  ctx.drawImage(img,0,0);

  for(let y=0;y<rows;y++){
    sea[y]=[];
    for(let x=0;x<cols;x++){
      const px = x*GRID;
      const py = y*GRID;
      const d = ctx.getImageData(px,py,1,1).data;
      // blue-ish pixels = water
      sea[y][x] = d[2] > d[1] && d[2] > d[0];
    }
  }
};

/* =========================
   A* PATHFINDING (90°)
========================= */
function findPath(start,end){
  const sx = Math.floor(start[1]/GRID);
  const sy = Math.floor(start[0]/GRID);
  const ex = Math.floor(end[1]/GRID);
  const ey = Math.floor(end[0]/GRID);

  const open = [[sx,sy]];
  const came = {};
  const key = (x,y)=>x+','+y;

  while(open.length){
    const [x,y] = open.shift();
    if(x===ex && y===ey) break;

    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=cols||ny>=rows) return;
      if(!sea[ny][nx]) return;
      const k = key(nx,ny);
      if(came[k]) return;
      came[k] = [x,y];
      open.push([nx,ny]);
    });
  }

  const path=[];
  let cur=[ex,ey];
  while(cur){
    path.push([cur[1]*GRID, cur[0]*GRID]);
    cur = came[key(cur[0],cur[1])];
  }
  return path.reverse();
}

/* =========================
   INTERACTION
========================= */
let selected=[], line=null;

ports.forEach(p=>{
  const m=L.marker(p.coords,{icon:portIcon(false)}).addTo(map);
  p.marker=m;

  L.marker(p.coords,{
    icon:L.divIcon({
      className:'port-label',
      html:p.name,
      iconAnchor:[-10,-14]
    })
  }).addTo(map);

  m.on('click',()=>{
    if(selected.includes(p)) return;
    selected.push(p);
    if(selected.length>2) selected.shift();
    draw();
  });
});

map.on('click',()=>{
  selected=[];
  if(line){map.removeLayer(line);line=null;}
});

function draw(){
  ports.forEach(p=>p.marker.setIcon(portIcon(selected.includes(p))));
  if(line){map.removeLayer(line);line=null;}
  if(selected.length<2) return;

  const pts=findPath(selected[0].coords,selected[1].coords);
  line=L.polyline(pts,{color:'#00bcd4',weight:4}).addTo(map);
}
</script>
</body>
</html>
